<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <title>Kai Wu | Structure from Motion Tutorial</title>
  <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design.
">

  <link rel="shortcut icon" href="https://imkaywu.github.io/assets/img/favicon.ico">
  <link rel="stylesheet" href="https://imkaywu.github.io/assets/css/main.css">
  <link rel="canonical" href="https://imkaywu.github.io/tutorials/sfm/">
</head>

  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'></script>

  <body>

    <header class="site-header">

  <div class="wrapper">

    
    <span class="site-title">
        
        <strong>Kai</strong> Wu
    </span>
    

    <nav class="site-nav">

      <div class="trigger">
        <!-- About -->
        <a class="page-link" href="https://imkaywu.github.io/">about</a>

        <!-- Blog -->
        <a class="page-link" href="https://imkaywu.github.io/blog/">blog</a>

        <!-- Pages -->
        
          
        
          
            <a class="page-link" href="https://imkaywu.github.io/code/">code</a>
          
        
          
        
          
            <a class="page-link" href="https://imkaywu.github.io/links/">links</a>
          
        
          
        
          
            <a class="page-link" href="https://imkaywu.github.io/projects/">projects</a>
          
        
          
            <a class="page-link" href="https://imkaywu.github.io/tutorials/">tutorials</a>
          
        
          
        
          
        
          
        
          
        

        <!-- CV link -->
        <!-- <a class="page-link" href="https://imkaywu.github.io/assets/pdf/CV.pdf">vitae</a> -->

      </div>
    </nav>

  </div>

</header>



    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Structure from Motion Tutorial</h1>
    <h5 class="post-description"></h5>
  </header>

  <article class="post-content Structure from Motion Tutorial clearfix">
    <p>Structure from Motion is like the holy grail of multiple view geometry. It is a process of estimating camera pose and retrieving a sparse reconstruction simultaneously. In this tutorial, I’ll discuss every step of this technique and provide detailed implementation using <a href="https://imkaywu.github.io/open3DCV/">open3DCV</a>. The source code can be found <a href="https://github.com/imkaywu/open3DCV/blob/master/test/sfm.cc">here</a>.</p>

<h3 id="table-of-content">Table of Content</h3>
<ol>
  <li><a href="#test_image">Test images</a></li>
  <li><a href="#image_io">Image IO</a></li>
  <li><a href="#feature_detection">Feature detection</a></li>
  <li><a href="#descriptor_extraction">Descriptor extraction</a></li>
  <li><a href="#feature_matching">Feature matching</a>
    <ul>
      <li><a href="#class_dmatch">class <code class="highlighter-rouge">DMatch</code></a></li>
      <li><a href="#class_pair">class <code class="highlighter-rouge">Pair</code></a></li>
    </ul>
  </li>
  <li><a href="#relative_pose">Relative pose estimation</a>
    <ul>
      <li><a href="#known_intrinsics">Known intrinsic parameters</a>
        <ul>
          <li><a href="#essential">Essential matrix estimation</a></li>
          <li><a href="#fundamental">Fundamental matrix estimation</a></li>
          <li><a href="#rigid_pose">Rigid pose from Essential matrix</a></li>
        </ul>
      </li>
      <li><a href="#unknown_intrinsics">Unknown intrinsic parameters</a>
        <ul>
          <li><a href="#homography">Homography estimation</a></li>
          <li><a href="#f_from_homog">focal length from Homography</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#triangulation">N-view triangulation</a>
    <ul>
      <li><a href="#class_graph">class <code class="highlighter-rouge">Graph</code></a></li>
    </ul>
  </li>
  <li><a href="#bundle_adjustment">Bundle adjustment</a></li>
  <li><a href="#2v_sfm">Two-view SfM</a></li>
  <li><a href="#nv_sfm">N-view SfM</a></li>
  <li><a href="#output">Output</a></li>
  <li><a href="#result">Results</a></li>
</ol>

<p><a id="test_image"></a></p>
<h3 id="0-test-images">0. Test images</h3>
<p>I used the <code class="highlighter-rouge">bust</code> images from Jianxiong Xiao’s SfM tutorial, and <code class="highlighter-rouge">templeRing</code> dataset from Middlebury mview datasets. The directory of the test images is</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">string</span> <span class="n">idir</span> <span class="o">=</span> <span class="s">"/Users/BlacKay/Documents/Projects/Images/test/bust/"</span><span class="p">;</span>
<span class="n">string</span> <span class="n">idir</span> <span class="o">=</span> <span class="s">"/Users/BlacKay/Documents/Projects/Images/test/templeRing/"</span><span class="p">;</span>
</code></pre>
</div>

<p><a id="image_io"></a></p>
<h3 id="1-image-io">1. Image IO</h3>
<p>The image naming convention follows that of PMVS. For instance, the first image is named as <code class="highlighter-rouge">00000000.jpg</code>, the second is named as <code class="highlighter-rouge">00000001.jpg</code>, and so on.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">nimages</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">iname</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Image</span><span class="o">&gt;</span> <span class="n">images</span><span class="p">(</span><span class="n">nimages</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nimages</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">sprintf</span><span class="p">(</span><span class="n">iname</span><span class="p">,</span> <span class="s">"%s/%08d.jpg"</span><span class="p">,</span> <span class="n">idir</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">read</span><span class="p">(</span><span class="n">iname</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p><a id="feature_detection"></a></p>
<h3 id="2-feature-detection">2. Feature detection</h3>
<p>The currently implemented feature detector is SIFT detector, and more feature detectors are under development. The configuration class <code class="highlighter-rouge">SiftParam</code> needs eight parameters to configure both SIFT detector and descriptor, the first five is responsible for the detector while the last three is responsible for the descriptor. The datatype <code class="highlighter-rouge">Keypoint</code> is used to hold the detected keypoint.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">SiftParams</span> <span class="n">sift_param</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">10.0</span><span class="n">f</span> <span class="o">/</span> <span class="mf">255.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">INFINITY</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">Sift</span> <span class="n">sift</span><span class="p">(</span><span class="n">sift_param</span><span class="p">);</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Keypoint</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">keys</span><span class="p">(</span><span class="n">nimages</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Keypoint</span><span class="o">&gt;</span><span class="p">());</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Vecf</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">descs</span><span class="p">(</span><span class="n">nimages</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Vecf</span><span class="o">&gt;</span><span class="p">());</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nimages</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">sift</span><span class="p">.</span><span class="n">detect_keypoints</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">sift</span><span class="p">.</span><span class="n">extract_descriptors</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">descs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">sift</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span> <span class="c1">// don't forget this
</span><span class="p">}</span>
</code></pre>
</div>

<div class="img_row">
    <img class="col one" src="/assets/img/open3DCV/sfm/feature1.jpg" alt="" title="example image" />
    <img class="col one" src="/assets/img/open3DCV/sfm/feature2.jpg" alt="" title="example image" />
    <img class="col one" src="/assets/img/open3DCV/sfm/feature3.jpg" alt="" title="example image" />
</div>
<div class="img_row">
    <img class="col one" src="/assets/img/open3DCV/sfm/feature4.jpg" alt="" title="example image" />
    <img class="col one" src="/assets/img/open3DCV/sfm/feature5.jpg" alt="" title="example image" />
</div>
<div class="col three caption">
    Results of feature detection.
</div>

<p><a id="descriptor_extraction"></a></p>
<h3 id="3-descriptor-extraction">3. Descriptor extraction</h3>
<p>Feature descriptor is extracted per keypoint, though theoretically, more than one descriptor is possible (at most 4). Currently, only SIFT descriptor is implemented, but more descriptors are under developments. The last three parameters of the <code class="highlighter-rouge">SiftParam</code> class is responsible for the configuration of the SIFT descriptor. Each descriptor is a 128 vector which is hold by a type <code class="highlighter-rouge">Vec</code> or <code class="highlighter-rouge">Vecf</code>. See the code above.</p>

<p><a id="feature_matching"></a></p>
<h3 id="4-feature-matching">4. Feature matching</h3>
<p>Once features have been detected and descriptors extracted in each image, the system matches features between each pair of images in the input image set. The number of image pairs is <script type="math/tex">\binom{N}{2}</script>, where <script type="math/tex">N</script> is the size of the image set. Let <script type="math/tex">\{f_I\}</script> denote the set of features detected in image <script type="math/tex">I</script> and <script type="math/tex">d(f_I^m)</script> descriptor of feature <script type="math/tex">f_I^m</script>. For each pair of images <script type="math/tex">I</script> and <script type="math/tex">J</script>, the system considers each feature <script type="math/tex">f_I^m\in \{f_I\}</script> and finds its nearest neighbor <script type="math/tex">f_J^n\in \{f_J\}</script>:</p>

<script type="math/tex; mode=display">f_J^n = argmin_{f_J^p\in \{f_J\}} dist(d(f_I^m), d(f_J^p))</script>

<p>where <script type="math/tex">dist(\cdot, \cdot)</script> is a user-specified distance metric. This brute-force approach can be replaced by using an approximate nearest neighbour library, such as <a href="">FLANN</a>, <a href="">ANN</a>, <a href="">Nanoflann</a>, and so on. To make the matching results more robust, a bi-directional verification is performed, which requires that <script type="math/tex">f_I^m</script> and <script type="math/tex">f_J^n</script> need to be among the top <script type="math/tex">K</script> matching points of one another. The information of a pair of matching keypoints is stored in a type <code class="highlighter-rouge">DMatch</code>, which is discussed below.</p>

<p><a id="class_dmatch"></a></p>
<h4 id="class-dmatch">class <code class="highlighter-rouge">DMatch</code></h4>
<p>The datatype <code class="highlighter-rouge">DMatch</code> holds the information of a pair of correspondening features, and is defined as follows:</p>

<ul>
  <li><code class="highlighter-rouge">std::pair&lt;int, int&gt; ind_key_</code> holds the indexes of the matching keypoints;</li>
  <li><code class="highlighter-rouge">std::pair&lt;Vec2f, Vec2f&gt; point_</code> holds the 2D positions of the matching keypoints.</li>
</ul>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DMatch</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">DMatch</span> <span class="p">()</span> <span class="p">{};</span>
    <span class="n">DMatch</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">r_ikey1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">r_ikey2</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">dist</span><span class="p">)</span> <span class="o">:</span>
        <span class="n">ind_key_</span><span class="p">(</span><span class="n">r_ikey1</span><span class="p">,</span> <span class="n">r_ikey2</span><span class="p">),</span> <span class="n">dist_</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="p">{};</span>
    <span class="n">DMatch</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">r_ikey1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">r_ikey2</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vec2f</span> <span class="n">r_pt1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vec2f</span> <span class="n">r_pt2</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">dist</span><span class="p">)</span> <span class="o">:</span>
        <span class="n">ind_key_</span><span class="p">(</span><span class="n">r_ikey1</span><span class="p">,</span> <span class="n">r_ikey2</span><span class="p">),</span> <span class="n">point_</span><span class="p">(</span><span class="n">r_pt1</span><span class="p">,</span> <span class="n">r_pt2</span><span class="p">),</span> <span class="n">dist_</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="p">{};</span>
    <span class="n">DMatch</span> <span class="p">(</span><span class="k">const</span> <span class="n">DMatch</span><span class="o">&amp;</span> <span class="n">match</span><span class="p">)</span> <span class="o">:</span>
        <span class="n">ind_key_</span><span class="p">(</span><span class="n">match</span><span class="p">.</span><span class="n">ind_key_</span><span class="p">),</span> <span class="n">point_</span><span class="p">(</span><span class="n">match</span><span class="p">.</span><span class="n">point_</span><span class="p">),</span> <span class="n">dist_</span><span class="p">(</span><span class="n">match</span><span class="p">.</span><span class="n">dist_</span><span class="p">)</span> <span class="p">{};</span>
    
    <span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">dist</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">ind_key_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Vec2f</span><span class="p">,</span> <span class="n">Vec2f</span><span class="o">&gt;</span> <span class="n">point_</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">dist_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
</div>

<p><a id="class_pair"></a></p>
<h4 id="class-pair">class <code class="highlighter-rouge">Pair</code></h4>
<p>Before heading to the next section of estimating the relative pose of an image pair, we first define the most fundmental data structure used in pairwise image matching, which is named <code class="highlighter-rouge">Pair</code>. It stores everything regaring the two-view geometry, including matching features, fundamental matrix, essential matrix, relative rotation and translation, and so on. A brief summary of the class <code class="highlighter-rouge">Pair</code> and the declaration is as follows:</p>
<ul>
  <li>camera indexes: <code class="highlighter-rouge">ind_cam_</code>;</li>
  <li>matching features: <code class="highlighter-rouge">matches_</code>;</li>
  <li>fundamental and essential matrix: <code class="highlighter-rouge">F_</code>, <code class="highlighter-rouge">E_</code>;</li>
  <li>intrinsics and extrinsics of the corresponding cameras: <code class="highlighter-rouge">intrinsics_mat_</code>, <code class="highlighter-rouge">extrinsics_mat_</code>.</li>
</ul>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Pair</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Pair</span><span class="p">();</span>
    <span class="n">Pair</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">cam1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">cam2</span><span class="p">);</span>
    <span class="n">Pair</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">cam1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">cam2</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Vec2f</span><span class="p">,</span> <span class="n">Vec2f</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">matches</span><span class="p">);</span>
    <span class="n">Pair</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">cam1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">cam2</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">DMatch</span><span class="o">&gt;&amp;</span> <span class="n">matches</span><span class="p">);</span>
    <span class="o">~</span><span class="n">Pair</span><span class="p">();</span>
    
    <span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">ind_cam1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">ind_cam2</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">update_matches</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">vote_inlier</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">update_intrinsics</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">f</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">h</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Pair</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">baseline_angle</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">cams_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">DMatch</span><span class="o">&gt;</span> <span class="n">matches_</span><span class="p">;</span>
    <span class="n">Mat3f</span> <span class="n">F_</span><span class="p">;</span>
    <span class="n">Mat3f</span> <span class="n">E_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Mat3f</span><span class="o">&gt;</span> <span class="n">intrinsics_mat_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Mat34f</span><span class="o">&gt;</span> <span class="n">extrinsics_mat_</span><span class="p">;</span>
    
<span class="p">};</span>
</code></pre>
</div>

<p>See below some of the matching results:</p>
<div class="img_row">
    <img class="col one" src="/assets/img/open3DCV/sfm/matching_inlier1_2.jpg" alt="" title="example image" />
    <img class="col one" src="/assets/img/open3DCV/sfm/matching_inlier2_3.jpg" alt="" title="example image" />
    <img class="col one" src="/assets/img/open3DCV/sfm/matching_inlier3_4.jpg" alt="" title="example image" />
</div>
<div class="img_row">
    <img class="col one" src="/assets/img/open3DCV/sfm/matching_inlier4_5.jpg" alt="" title="example image" />
</div>
<div class="col three caption">
    Results of feature matching.
</div>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">Pair</span><span class="o">&gt;</span> <span class="n">pairs</span><span class="p">;</span>
<span class="n">Matcher_Param</span> <span class="n">matcher_param</span><span class="p">(</span><span class="mf">0.6</span><span class="o">*</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
<span class="n">Matcher_Flann</span> <span class="n">matcher</span><span class="p">(</span><span class="n">matcher_param</span><span class="p">);</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">DMatch</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">matches_pairwise</span><span class="p">(</span><span class="n">nimages</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">DMatch</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">());</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nimages</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">matches_pairwise</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="n">nimages</span><span class="o">-</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nimages</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">DMatch</span><span class="o">&gt;&amp;</span> <span class="n">matches</span> <span class="o">=</span> <span class="n">matches_pairwise</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)];</span>
    <span class="n">matcher</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="n">descs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">descs</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">matches</span><span class="p">);</span>
    <span class="n">matcher</span><span class="p">.</span><span class="n">matching_keys</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">keys</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">matches</span><span class="p">);</span>
    <span class="n">pairs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Pair</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">matches</span><span class="p">));</span>
    <span class="n">string</span> <span class="n">fname</span> <span class="o">=</span> <span class="n">odir</span><span class="o">+</span><span class="s">"matching"</span><span class="o">+</span><span class="n">to_string</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s">"_"</span><span class="o">+</span><span class="n">to_string</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s">".txt"</span><span class="p">;</span>
    <span class="n">write_matches</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">matches</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="nb">false</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">draw_matches</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">images</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">keys</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">matches</span><span class="p">,</span> <span class="n">odir</span><span class="o">+</span><span class="s">"matching"</span><span class="o">+</span><span class="n">to_string</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s">"_"</span><span class="o">+</span><span class="n">to_string</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Image ("</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s">"): matches number: "</span> <span class="o">&lt;&lt;</span> <span class="n">matches</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p><a id="relative_pose"></a></p>
<h3 id="5-relative-pose-estimation">5. Relative pose estimation</h3>
<p>For each pair of images with sufficient number of matches/correspondences, a relative pose estimation is performed, which is followed by a triangulation step, a bundle adjustment step, and then various verification steps to check if this pair of images holds enough information for subsequent steps, or if the estimated relative pose is accurate enough. This step is a crucial part of two-view SfM, and is generally divided into two groups, one with calibrated cameras, or known focal length, and one with uncalibrated cameras, or unknown focal length.</p>

<p><a id="known_intrinsics"></a></p>
<h4 id="known-intrinsic-parameters">Known intrinsic parameters</h4>
<p>SfM using calibrated cameras is the most common case in practice since the camera intrinsics remain fixed unless manually changed. This is the case where euclidean (metric) reconstruction is possible, whereas in the uncalibrated case, only projective reconstruction is possible.</p>

<p><a id="essential"></a></p>
<h5 id="estimate-essential-matrix">Estimate essential matrix</h5>
<p>Essential matrix can be estimated using the <code class="highlighter-rouge">5-point algorithm</code> + <code class="highlighter-rouge">RANSAC</code>. This approach is still under development since currently the Essential Matrix is computed from the estimated Fundamental Matrix, the underlying theory is as follows:</p>

<script type="math/tex; mode=display">E = K_2^\top F K_1</script>

<p><a id="fundamental"></a></p>
<h5 id="estimate-fundamental-matrix">Estimate fundamental matrix</h5>
<p>The Fundamental matrix can be estimated using the <code class="highlighter-rouge">7-point algorithm</code> + <code class="highlighter-rouge">RANSAC</code>. I choose <code class="highlighter-rouge">7-point algorithm</code> over <code class="highlighter-rouge">8-point algorithm</code> because it requires less data thus less iterations are needed to achieve the same probability of inliers. The theory and implementation of the estimation of <a href="https://imkaywu.github.io/blog/2017/06/fundamental-matrix/">Fundamental matrix</a>, <a href="https://imkaywu.github.io/blog/2017/08/ransac-framework/">RANSAC</a>, and <a href="https://imkaywu.github.io/blog/2017/09/robust-fundamental-matrix/">robust estimation of fundamental matrix using RANSAC</a> are discussed in depth in the corresponding blog posts. The estimated matrices regarding the epipolar geometry are stored in the data structure <code class="highlighter-rouge">Pair</code> as mention previously. The source code of estimating fundamental matrix is as follows:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pairs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ------ image pair ------
</span>    <span class="n">Pair</span><span class="o">&amp;</span> <span class="n">pair</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">nmatches</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">matches_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">ind1</span> <span class="o">=</span> <span class="n">pair</span><span class="p">.</span><span class="n">cams_</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">ind2</span> <span class="o">=</span> <span class="n">pair</span><span class="p">.</span><span class="n">cams_</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"*******************************"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" 2-View SfM of image "</span> <span class="o">&lt;&lt;</span> <span class="n">ind1</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s">" and "</span> <span class="o">&lt;&lt;</span> <span class="n">ind2</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"*******************************"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="c1">// ------ estimate Fundamental matrix ------
</span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">params</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">vote_inlier</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">nmatches</span><span class="p">];</span>
    <span class="n">Param_Estimator</span><span class="o">&lt;</span><span class="n">DMatch</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;*</span> <span class="n">fund_esti</span> <span class="o">=</span> <span class="k">new</span> <span class="n">open3DCV</span><span class="o">::</span><span class="n">Fundamental_Estimator</span><span class="p">(</span><span class="mf">1e-8</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">ratio_inlier</span> <span class="o">=</span> <span class="n">Ransac</span><span class="o">&lt;</span><span class="n">DMatch</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;::</span><span class="n">estimate</span><span class="p">(</span><span class="n">fund_esti</span><span class="p">,</span> <span class="n">pair</span><span class="p">.</span><span class="n">matches_</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">,</span> <span class="n">vote_inlier</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ratio of matching inliers: "</span> <span class="o">&lt;&lt;</span> <span class="n">ratio_inlier</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ratio_inlier</span> <span class="o">&lt;</span> <span class="n">thresh_inlier_ratio</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">delete</span> <span class="p">[]</span> <span class="n">vote_inlier</span><span class="p">;</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">pair</span><span class="p">.</span><span class="n">F_</span> <span class="o">&lt;&lt;</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span>
               <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span>
               <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

    <span class="c1">// ------ other more code ------
</span><span class="p">}</span>
</code></pre>
</div>
<div class="img_row">
    <img class="col one" src="/assets/img/open3DCV/sfm/epipolar1_2.jpg" alt="" title="example image" />
    <img class="col one" src="/assets/img/open3DCV/sfm/epipolar2_3.jpg" alt="" title="example image" />
    <img class="col one" src="/assets/img/open3DCV/sfm/epipolar3_4.jpg" alt="" title="example image" />
</div>
<div class="img_row">
    <img class="col one" src="/assets/img/open3DCV/sfm/epipolar4_5.jpg" alt="" title="example image" />
</div>
<div class="col three caption">
    Results of fundamental matrix.
</div>

<p><a id="rigid_pose"></a></p>
<h5 id="rigid-pose-estimation-from-essential-matrix">Rigid pose estimation from Essential matrix</h5>
<p>We can estimate the relative position and orientation of two cameras from Essential matrix, the theory and implementation are discussed in depth in <a href="https://imkaywu.github.io//blog/2017/09/relative-pose/">this post</a>. The source code of estimating the rigid pose is as follows:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// ------ estimate relative pose ------
</span><span class="k">const</span> <span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">1520.4</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="mf">302.32</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="mf">246.87</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>
<span class="n">pair</span><span class="p">.</span><span class="n">update_intrinsics</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
<span class="n">pair</span><span class="p">.</span><span class="n">E_</span> <span class="o">=</span> <span class="n">pair</span><span class="p">.</span><span class="n">intrinsics_mat_</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span> <span class="n">pair</span><span class="p">.</span><span class="n">F_</span> <span class="o">*</span> <span class="n">pair</span><span class="p">.</span><span class="n">intrinsics_mat_</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">Rt_from_E</span><span class="p">(</span><span class="n">pair</span><span class="p">);</span>
</code></pre>
</div>

<p><a id="unknown_intrinsics"></a></p>
<h4 id="unknown-intrinsic-parameters">Unknown intrinsic parameters</h4>
<p>This is the case where uncalibrated cameras are used, and the scene is reconstructed up to a projective projection. This section is still under development.</p>

<p><a id="homography"></a></p>
<h5 id="estimate-homography">Estimate homography</h5>
<p>[TBD]</p>

<p><a id="f_from_homog"></a></p>
<h5 id="estimate-focal-length-from-homography">Estimate focal length from homography</h5>
<p>[TBD]</p>

<p><a id="triangulation"></a></p>
<h3 id="6-n-view-triangulation">6. N-view triangulation</h3>
<p>From calibrated cameras and correspondences, the positions of the 3D points can be estimated using N-view triangulation techniques. The theory and implementation of various triangulation techniques are discussed in depth in <a href="https://imkaywu.github.io//blog/2017/07/triangulation/">this post</a>. Recall that we defined a data structure <code class="highlighter-rouge">Pair</code> for two-view case, a new data structure named <code class="highlighter-rouge">Graph</code> is defined for the N-view case.</p>

<p><a id="class_graph"></a></p>
<h4 id="class-graph">class <code class="highlighter-rouge">Graph</code></h4>
<p>The class <code class="highlighter-rouge">Graph</code> is heavily used hereafter, it is a data structure that stores information of multiple cameras with sufficient amount of matching features, the corresponding camera poses/orientations, and a sparse 3D reconstruction, the detailed definition is as follows:</p>

<ul>
  <li>number of cameras: <code class="highlighter-rouge">ncams_</code>;</li>
  <li>indexes of cameras: <code class="highlighter-rouge">ind_cam_</code>;</li>
  <li>intrinsics and extrinsics of cameras: <code class="highlighter-rouge">intrinsics_mat_</code>, <code class="highlighter-rouge">extrinsics_mat_</code>;</li>
  <li>point tracks: <code class="highlighter-rouge">tracks_</code>. Each set of matching pixels across multiple images forms one track, which also corresponds to a single 3D point, i.e., each individual pixel in a track should be the projection of the same 3D point. It’s the N-view counterpart of <code class="highlighter-rouge">DMatch</code>.</li>
  <li>structure points: <code class="highlighter-rouge">structure_points_</code>, a data structure holds information of the estimated 3D point.</li>
</ul>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Graph</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Graph</span><span class="p">();</span>
    <span class="n">Graph</span><span class="p">(</span><span class="k">const</span> <span class="n">Pair</span><span class="o">&amp;</span> <span class="n">pair</span><span class="p">);</span>
    <span class="o">~</span><span class="n">Graph</span><span class="p">();</span>
    
    <span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="k">const</span> <span class="n">Pair</span><span class="o">&amp;</span> <span class="n">pair</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">index</span><span class="p">(</span><span class="kt">int</span> <span class="n">icam</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intersect</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Track</span><span class="o">&gt;&amp;</span> <span class="n">tracks1</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Track</span><span class="o">&gt;&amp;</span> <span class="n">tracks2</span><span class="p">);</span>
    
    <span class="kt">int</span> <span class="n">ncams_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ind_cam_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Mat3f</span><span class="o">&gt;</span> <span class="n">intrinsics_mat_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Mat34f</span><span class="o">&gt;</span> <span class="n">extrinsics_mat_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Track</span><span class="o">&gt;</span> <span class="n">tracks_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Structure_Point</span><span class="o">&gt;</span> <span class="n">structure_points_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
</div>

<p>The triangulation method, such as <code class="highlighter-rouge">triangulate_nonlinear(Graph&amp; graph)</code> takes a <code class="highlighter-rouge">Graph</code> object as input and compute the <code class="highlighter-rouge">structure_points_</code> from feature tracks <code class="highlighter-rouge">tracks_</code> and corresponding camera parameters <code class="highlighter-rouge">intrinsics_mat_</code> and <code class="highlighter-rouge">extrinsics_mat_</code>.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">triangulate_nonlinear</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="c1">// compute reprojection error
</span><span class="kt">float</span> <span class="n">error</span> <span class="o">=</span> <span class="n">reprojection_error</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"reprojection error (before bundle adjustment): "</span> <span class="o">&lt;&lt;</span> <span class="n">error</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre>
</div>

<p><a id="bundle_adjustment"></a></p>
<h3 id="7-bundle-adjustment">7. Bundle adjustment</h3>
<p>After successfully estimating the camera extrinsics as well as the 3D point positions, we proceed to optimize a reprojection error with respect to all estimated parameters. This process is known as <a href="https://en.wikipedia.org/wiki/Bundle_adjustment">bundle adjustment</a>, which is ubiquitously used as the last step in most feature-based estimation problems. The implementation of bundle adjustment of SfM using Ceres solver is discussed in <a href="https://imkaywu.github.io//blog/2017/09/sfm-bundle-adjustment/">this post</a>.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// ------ bundle adjustment ------
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"------ start bundle adjustment ------"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">Open3DCVBundleAdjustment</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">BUNDLE_NO_INTRINSICS</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">update_focal</span><span class="p">)</span>
    <span class="n">Open3DCVBundleAdjustment</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">BUNDLE_FOCAL_LENGTH</span><span class="p">);</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">update_intrinsic</span><span class="p">)</span>
    <span class="n">Open3DCVBundleAdjustment</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">BUNDLE_INTRINSICS</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"------ end bundle adjustment ------"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">error</span> <span class="o">=</span> <span class="n">reprojection_error</span><span class="p">(</span><span class="n">graph</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"reprojection error (after bundle adjustment): "</span> <span class="o">&lt;&lt;</span> <span class="n">error</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre>
</div>

<p><a id="2v_sfm"></a></p>
<h3 id="8-two-view-sfm">8. Two-view SfM</h3>
<p>Two-view SfM is performed on each pair of images with sufficient amount of matches. The pseudocode of two-view SfM is as follows:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Require: internal camera calibration (possibly from EXIF data)
Require: pairwise geometry consistent point correspondences
Ensure: 3D point cloud
Ensure: camera poses
for pair in pairs
  pick pair p in pairs
  * robustly estimate fundamental/essential matrix from images of p
  * robustly estimate pose and orientation
  triangulate matching points in two views
  perform bundle adjustment
  verify baseline angle, reprojection error, and so on. if successful, go to next step, if not, continue to next loop
  construct a graph g from pair p
end for
</code></pre>
</div>

<p>A demonstrative example of the results of two-view SfM is as follows:</p>
<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="o">*******************************</span>
 <span class="mi">2</span><span class="o">-</span><span class="n">View</span> <span class="n">SfM</span> <span class="n">of</span> <span class="n">image</span> <span class="mi">0</span> <span class="n">and</span> <span class="mi">1</span>
<span class="o">*******************************</span>
<span class="n">ratio</span> <span class="n">of</span> <span class="n">matching</span> <span class="n">inliers</span><span class="o">:</span> <span class="mf">0.988506</span>
<span class="n">number</span> <span class="n">of</span> <span class="n">matches</span><span class="o">:</span> <span class="mi">172</span>
<span class="n">reprojection</span> <span class="n">error</span> <span class="p">(</span><span class="n">before</span> <span class="n">bundle</span> <span class="n">adjustment</span><span class="p">)</span><span class="o">:</span> <span class="mf">3.87837</span>
<span class="n">reprojection</span> <span class="n">error</span> <span class="p">(</span><span class="n">after</span> <span class="n">bundle</span> <span class="n">adjustment</span><span class="p">)</span><span class="o">:</span> <span class="mf">0.43175</span>
<span class="o">*******************************</span>
 <span class="mi">2</span><span class="o">-</span><span class="n">View</span> <span class="n">SfM</span> <span class="n">of</span> <span class="n">image</span> <span class="mi">1</span> <span class="n">and</span> <span class="mi">2</span>
<span class="o">*******************************</span>
<span class="n">ratio</span> <span class="n">of</span> <span class="n">matching</span> <span class="n">inliers</span><span class="o">:</span> <span class="mf">0.916667</span>
<span class="n">number</span> <span class="n">of</span> <span class="n">matches</span><span class="o">:</span> <span class="mi">110</span>
<span class="n">reprojection</span> <span class="n">error</span> <span class="p">(</span><span class="n">before</span> <span class="n">bundle</span> <span class="n">adjustment</span><span class="p">)</span><span class="o">:</span> <span class="mf">2.25564</span>
<span class="n">reprojection</span> <span class="n">error</span> <span class="p">(</span><span class="n">after</span> <span class="n">bundle</span> <span class="n">adjustment</span><span class="p">)</span><span class="o">:</span> <span class="mf">0.381238</span>
<span class="o">*******************************</span>
 <span class="mi">2</span><span class="o">-</span><span class="n">View</span> <span class="n">SfM</span> <span class="n">of</span> <span class="n">image</span> <span class="mi">2</span> <span class="n">and</span> <span class="mi">3</span>
<span class="o">*******************************</span>
<span class="n">ratio</span> <span class="n">of</span> <span class="n">matching</span> <span class="n">inliers</span><span class="o">:</span> <span class="mf">0.967742</span>
<span class="n">number</span> <span class="n">of</span> <span class="n">matches</span><span class="o">:</span> <span class="mi">120</span>
<span class="n">reprojection</span> <span class="n">error</span> <span class="p">(</span><span class="n">before</span> <span class="n">bundle</span> <span class="n">adjustment</span><span class="p">)</span><span class="o">:</span> <span class="mf">2.01501</span>
<span class="n">reprojection</span> <span class="n">error</span> <span class="p">(</span><span class="n">after</span> <span class="n">bundle</span> <span class="n">adjustment</span><span class="p">)</span><span class="o">:</span> <span class="mf">0.238207</span>
<span class="o">*******************************</span>
 <span class="mi">2</span><span class="o">-</span><span class="n">View</span> <span class="n">SfM</span> <span class="n">of</span> <span class="n">image</span> <span class="mi">3</span> <span class="n">and</span> <span class="mi">4</span>
<span class="o">*******************************</span>
<span class="n">ratio</span> <span class="n">of</span> <span class="n">matching</span> <span class="n">inliers</span><span class="o">:</span> <span class="mf">0.840426</span>
<span class="n">number</span> <span class="n">of</span> <span class="n">matches</span><span class="o">:</span> <span class="mi">79</span>
<span class="n">reprojection</span> <span class="n">error</span> <span class="p">(</span><span class="n">before</span> <span class="n">bundle</span> <span class="n">adjustment</span><span class="p">)</span><span class="o">:</span> <span class="mf">1.19674</span>
<span class="n">reprojection</span> <span class="n">error</span> <span class="p">(</span><span class="n">after</span> <span class="n">bundle</span> <span class="n">adjustment</span><span class="p">)</span><span class="o">:</span> <span class="mf">0.178282</span>
</code></pre>
</div>

<p><a id="nv_sfm"></a></p>
<h3 id="9-n-view-sfm">9. N-view SfM</h3>
<p>After two-view SfM, an iterative step that merges multiple graphs into a global graph is performed, the pseudocode of this process is as follows:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Require: internal camera calibration (possibly from EXIF data)
Require: point tracks from multiple views
Require: a global graph contains all currently merged images
Ensure: 3D point cloud
Ensure: camera poses
for graph in graphs
  pick graph g in graphs having maximum number of common tracks with the global graph
  merge tracks of global graph with those of graph g
  triangulate tracks
  perform bundle adjustment
  remove track outliers based on baseline angle and reprojection error
  perform bundle adjustment
end for
</code></pre>
</div>

<p>The source code for N-view triangulation and N-view bundle adjustment are exactly the same as those of the 2-view counterparts. The source code of this N-view SfM is as follows:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Graph</span> <span class="n">global_graph</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nimages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"*******************************"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" N-View SfM: merging graph 0-"</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"*******************************"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">// ------ merge graphs ------
</span>    <span class="n">Graph</span><span class="o">::</span><span class="n">merge_graph</span><span class="p">(</span><span class="n">global_graph</span><span class="p">,</span> <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    
    <span class="c1">// ------ N-view triangulation ------
</span>    <span class="n">triangulate_nonlinear</span><span class="p">(</span><span class="n">global_graph</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">error</span> <span class="o">=</span> <span class="n">reprojection_error</span><span class="p">(</span><span class="n">global_graph</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"reprojection error (before bundle adjustment): "</span> <span class="o">&lt;&lt;</span> <span class="n">error</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    
    <span class="c1">// ------ N-view bundle adjustment ------
</span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"------ start bundle adjustment ------"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">Open3DCVBundleAdjustment</span><span class="p">(</span><span class="n">global_graph</span><span class="p">,</span> <span class="n">BUNDLE_PRINCIPAL_POINT</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"------ end bundle adjustment ------"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">reprojection_error</span><span class="p">(</span><span class="n">global_graph</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"reprojection error (after bundle adjustment): "</span> <span class="o">&lt;&lt;</span> <span class="n">error</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h4 id="merge-graphs">Merge graphs</h4>
<p>As we can see, the main challenge of this step is to merge multiple graphs into a global graph containing all camera parameters, feature tracks, and 3D structure points. This source code of this process is as follows:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Graph</span><span class="o">::</span><span class="n">merge_graph</span><span class="p">(</span><span class="n">Graph</span> <span class="o">&amp;</span><span class="n">graph1</span><span class="p">,</span> <span class="n">Graph</span> <span class="o">&amp;</span><span class="n">graph2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span><span class="p">;</span>
    
    <span class="c1">// find overlapping cameras
</span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">cams_common</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">graph1</span><span class="p">.</span><span class="n">ncams_</span><span class="p">,</span> <span class="n">graph2</span><span class="p">.</span><span class="n">ncams_</span><span class="p">));</span>
    <span class="n">iter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">set_intersection</span><span class="p">(</span><span class="n">graph1</span><span class="p">.</span><span class="n">cams_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">graph1</span><span class="p">.</span><span class="n">cams_</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">graph2</span><span class="p">.</span><span class="n">cams_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">graph2</span><span class="p">.</span><span class="n">cams_</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">cams_common</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
    <span class="n">cams_common</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">iter</span> <span class="o">-</span> <span class="n">cams_common</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
    
    <span class="c1">// find distinct cameras
</span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">cams_diff</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">graph1</span><span class="p">.</span><span class="n">ncams_</span><span class="p">,</span> <span class="n">graph2</span><span class="p">.</span><span class="n">ncams_</span><span class="p">));</span>
    <span class="n">iter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">set_difference</span><span class="p">(</span><span class="n">graph2</span><span class="p">.</span><span class="n">cams_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">graph2</span><span class="p">.</span><span class="n">cams_</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">graph1</span><span class="p">.</span><span class="n">cams_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">graph1</span><span class="p">.</span><span class="n">cams_</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">cams_diff</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
    <span class="n">cams_diff</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">iter</span> <span class="o">-</span> <span class="n">cams_diff</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">cams_common</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="k">return</span><span class="p">;</span>
    
    <span class="c1">// merge the camera intrinsic and extrinsic parameters
</span>    <span class="kt">int</span> <span class="n">ind_cam1</span> <span class="o">=</span> <span class="n">graph1</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">cams_common</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="kt">int</span> <span class="n">ind_cam2</span> <span class="o">=</span> <span class="n">graph2</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">cams_common</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">Mat34f</span> <span class="n">Rt1</span> <span class="o">=</span> <span class="n">graph1</span><span class="p">.</span><span class="n">extrinsics_mat_</span><span class="p">[</span><span class="n">ind_cam1</span><span class="p">];</span>
    <span class="n">Mat34f</span> <span class="n">Rt2</span> <span class="o">=</span> <span class="n">graph2</span><span class="p">.</span><span class="n">extrinsics_mat_</span><span class="p">[</span><span class="n">ind_cam2</span><span class="p">];</span>
    <span class="n">Mat34f</span> <span class="n">Rt21</span> <span class="o">=</span> <span class="n">concat_Rt</span><span class="p">(</span><span class="n">inv_Rt</span><span class="p">(</span><span class="n">Rt1</span><span class="p">),</span> <span class="n">Rt2</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">graph2</span><span class="p">.</span><span class="n">structure_points_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Vec3f</span><span class="o">&amp;</span> <span class="n">pt3d</span> <span class="o">=</span> <span class="n">graph2</span><span class="p">.</span><span class="n">structure_points_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">coords</span><span class="p">();</span>
        <span class="n">pt3d</span> <span class="o">=</span> <span class="n">Rt21</span> <span class="o">*</span> <span class="n">pt3d</span><span class="p">.</span><span class="n">homogeneous</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">Mat34f</span> <span class="n">Rt21t</span> <span class="o">=</span> <span class="n">inv_Rt</span><span class="p">(</span><span class="n">Rt21</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cams_diff</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">graph1</span><span class="p">.</span><span class="n">cams_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cams_diff</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">graph1</span><span class="p">.</span><span class="n">intrinsics_mat_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">graph2</span><span class="p">.</span><span class="n">intrinsics_mat_</span><span class="p">[</span><span class="n">graph2</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">cams_diff</span><span class="p">[</span><span class="n">i</span><span class="p">])]);</span>
        <span class="n">graph1</span><span class="p">.</span><span class="n">extrinsics_mat_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">concat_Rt</span><span class="p">(</span><span class="n">graph2</span><span class="p">.</span><span class="n">extrinsics_mat_</span><span class="p">[</span><span class="n">graph2</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">cams_diff</span><span class="p">[</span><span class="n">i</span><span class="p">])],</span> <span class="n">Rt21t</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">graph1</span><span class="p">.</span><span class="n">ncams_</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">graph1</span><span class="p">.</span><span class="n">cams_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">indexes</span><span class="p">;</span>
    <span class="n">sort</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">graph1</span><span class="p">.</span><span class="n">cams_</span><span class="p">,</span> <span class="n">graph1</span><span class="p">.</span><span class="n">cams_</span><span class="p">,</span> <span class="n">indexes</span><span class="p">);</span>
    <span class="n">reorder</span><span class="o">&lt;</span><span class="n">Mat3f</span><span class="o">&gt;</span><span class="p">(</span><span class="n">graph1</span><span class="p">.</span><span class="n">intrinsics_mat_</span><span class="p">,</span> <span class="n">indexes</span><span class="p">,</span> <span class="n">graph1</span><span class="p">.</span><span class="n">intrinsics_mat_</span><span class="p">);</span>
    <span class="n">reorder</span><span class="o">&lt;</span><span class="n">Mat34f</span><span class="o">&gt;</span><span class="p">(</span><span class="n">graph1</span><span class="p">.</span><span class="n">extrinsics_mat_</span><span class="p">,</span> <span class="n">indexes</span><span class="p">,</span> <span class="n">graph1</span><span class="p">.</span><span class="n">extrinsics_mat_</span><span class="p">);</span>
    
    <span class="k">const</span> <span class="kt">int</span> <span class="n">ntracks</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">graph1</span><span class="p">.</span><span class="n">tracks_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">graph2</span><span class="p">.</span><span class="n">tracks_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Track</span><span class="o">&amp;</span> <span class="n">track2</span> <span class="o">=</span> <span class="n">graph2</span><span class="p">.</span><span class="n">tracks_</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="kt">bool</span> <span class="n">is_track_connected</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ntracks</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Track</span><span class="o">&amp;</span> <span class="n">track1</span> <span class="o">=</span> <span class="n">graph1</span><span class="p">.</span><span class="n">tracks_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">feats_common</span><span class="p">;</span>
            <span class="n">Track</span><span class="o">::</span><span class="n">find_overlapping_keypoints</span><span class="p">(</span><span class="n">track1</span><span class="p">,</span> <span class="n">track2</span><span class="p">,</span> <span class="n">feats_common</span><span class="p">);</span>
            <span class="c1">// find overlapping feature tracks from common cameras
</span>            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">feats_common</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="n">Graph</span><span class="o">::</span><span class="n">merge_tracks</span><span class="p">(</span><span class="n">track1</span><span class="p">,</span> <span class="n">track2</span><span class="p">,</span> <span class="n">feats_common</span><span class="p">);</span>
                <span class="n">is_track_connected</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// find non-overlapping feature tracks from common cameras
</span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_track_connected</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">graph1</span><span class="p">.</span><span class="n">add_track</span><span class="p">(</span><span class="n">track2</span><span class="p">);</span>
            <span class="n">graph1</span><span class="p">.</span><span class="n">add_struct_pt</span><span class="p">(</span><span class="n">graph2</span><span class="p">.</span><span class="n">structure_points_</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// find new features from non-overlapping cameras, this part is not needed for now
</span><span class="p">}</span>
</code></pre>
</div>

<p>A demonstrative results of this N-view SfM is as follows:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="o">*******************************</span>
 <span class="n">N</span><span class="o">-</span><span class="n">View</span> <span class="n">SfM</span><span class="o">:</span> <span class="n">merging</span> <span class="n">graph</span> <span class="mi">0</span><span class="o">-</span><span class="mi">1</span>
<span class="o">*******************************</span>
<span class="n">reprojection</span> <span class="n">error</span> <span class="p">(</span><span class="n">before</span> <span class="n">bundle</span> <span class="n">adjustment</span><span class="p">)</span><span class="o">:</span> <span class="mf">1.76187</span>
<span class="n">reprojection</span> <span class="n">error</span> <span class="p">(</span><span class="n">after</span> <span class="n">bundle</span> <span class="n">adjustment</span><span class="p">)</span><span class="o">:</span> <span class="mf">0.340547</span>
<span class="o">*******************************</span>
 <span class="n">N</span><span class="o">-</span><span class="n">View</span> <span class="n">SfM</span><span class="o">:</span> <span class="n">merging</span> <span class="n">graph</span> <span class="mi">0</span><span class="o">-</span><span class="mi">2</span>
<span class="o">*******************************</span>
<span class="n">reprojection</span> <span class="n">error</span> <span class="p">(</span><span class="n">before</span> <span class="n">bundle</span> <span class="n">adjustment</span><span class="p">)</span><span class="o">:</span> <span class="mf">3.91939</span>
<span class="n">reprojection</span> <span class="n">error</span> <span class="p">(</span><span class="n">after</span> <span class="n">bundle</span> <span class="n">adjustment</span><span class="p">)</span><span class="o">:</span> <span class="mf">0.328052</span>
<span class="o">*******************************</span>
 <span class="n">N</span><span class="o">-</span><span class="n">View</span> <span class="n">SfM</span><span class="o">:</span> <span class="n">merging</span> <span class="n">graph</span> <span class="mi">0</span><span class="o">-</span><span class="mi">3</span>
<span class="o">*******************************</span>
<span class="n">reprojection</span> <span class="n">error</span> <span class="p">(</span><span class="n">before</span> <span class="n">bundle</span> <span class="n">adjustment</span><span class="p">)</span><span class="o">:</span> <span class="mf">4.75183</span>
<span class="n">reprojection</span> <span class="n">error</span> <span class="p">(</span><span class="n">after</span> <span class="n">bundle</span> <span class="n">adjustment</span><span class="p">)</span><span class="o">:</span> <span class="mf">0.321569</span>
</code></pre>
</div>

<p><a id="output"></a></p>
<h3 id="10-output">10. Output</h3>
<p>For now, the camera parameters are written to PMVS-compatible files.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">write_sfm</span><span class="p">(</span><span class="n">global_graph</span><span class="p">);</span>
</code></pre>
</div>

<p><a id="result"></a></p>
<h3 id="11-results">11. Results</h3>
<p>The lack of detail in the first dataset could be due to the lack of surface texture.</p>
<div class="img_row">
    <img class="col half" src="/assets/img/open3DCV/sfm/sfm_camera_pose_bust.png" alt="" title="sfm results" />
    <img class="col half" src="/assets/img/open3DCV/sfm/bust.png" alt="" title="sfm results" />
</div>
<div class="img_row">
    <img class="col one" src="/assets/img/open3DCV/sfm/sfm_camera_pose_temple_front.png" alt="" title="sfm results" />
    <img class="col one" src="/assets/img/open3DCV/sfm/sfm_camera_pose_temple_top.png" alt="" title="sfm results" />
    <img class="col one" src="/assets/img/open3DCV/sfm/temple.png" alt="" title="sfm results" />
</div>
<div class="col three caption">
    Estimated camera position and orientation, and the dense reconstruction result using PMVS
</div>

  </article>

  

  

</div>

      </div>
    </div>

    <footer>

  <div class="wrapper">
    &copy; Copyright 2017 Kai Wu.
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>.

    
  </div>

</footer>


    <!-- Load jQuery -->
<script src="//code.jquery.com/jquery-1.12.4.min.js"></script>

<!-- Load Common JS -->
<script src="https://imkaywu.github.io/assets/js/common.js"></script>





<!-- Include custom icon fonts -->
<link rel="stylesheet" href="https://imkaywu.github.io/assets/css/font-awesome.min.css">
<link rel="stylesheet" href="https://imkaywu.github.io/assets/css/academicons.min.css">

<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-XXXXXXXX-X', 'auto');
ga('send', 'pageview');
</script>


  </body>

</html>
